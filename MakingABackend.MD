# Making a backend

## Part 0: Introduction

- These notes were added while making a new AWS backend for Amazon AWS.

## Part 1: The skeleton:

To start with, I just need to create a bunch of boilerplate which will eventually be filled in with all of the lovely AWS details!

### Defining the awsBackend project:

- Added entries to project/Settings.scala, project/Dependencies.scala and build.sbt
- This was mainly just a copy/paste from existing backend projects. I made a few typos renaming everything and linking the dependencies properly though!
- E.g. In my first commit I forgot to update the libraryDependencies name for my AWS backend project:
```
  val awsBackendSettings = List(
    name := "cromwell-aws-backend",
    libraryDependencies ++= awsBackendDependencies
  ) ++ commonSettings
```
- I guessed that I'd need the AWS SDK so I included that immediately in Dependencies.scala:
```
  val awsBackendDependencies = List(
    "com.amazonaws" % "aws-java-sdk" % "1.11.41"
  )
```
- In build.scala I had to also edit the `lazy val root` to include a new `.aggregate(awsBackend)` and a new `.dependsOn(awsBackend)`

### Directory structure:

- This is probably going to be autogenerated for you in the directories specified in the above files. I'd already added my own directory structure and sbt managed to pick it up correctly in `supportedBackends/aws`.

### AWS Job Execution Actor:
- To run a job, Cromwell needs to instantiate a Job Execution actor. I'll fill in the details later but for now, I'll just add the constructor, props, and an unimplemented method definition for `execute`:
```
class AwsJobExecutionActor(override val jobDescriptor: BackendJobDescriptor,
                           override val configurationDescriptor: BackendConfigurationDescriptor) extends BackendJobExecutionActor {

  override def execute: Future[BackendJobExecutionResponse] = ???
}

object AwsJobExecutionActor {
  def props(jobDescriptor: BackendJobDescriptor,
            configurationDescriptor: BackendConfigurationDescriptor): Props = Props(new AwsJobExecutionActor(jobDescriptor, configurationDescriptor))
}
```

### Actor factory:
- This is the class which tells Cromwell which classes represent job execution actors, initialization actors and so on. I'm just adding a skeleton for now, with a constructor of the form the Cromwell expects:
```
case class AwsBackendActorFactory(name: String, configurationDescriptor: BackendConfigurationDescriptor) extends BackendLifecycleActorFactory {

  override def jobExecutionActorProps(jobDescriptor: BackendJobDescriptor,
                                      initializationData: Option[BackendInitializationData],
                                      serviceRegistryActor: ActorRef,
                                      backendSingletonActor: Option[ActorRef]): Props = AwsJobExecutionActor.props(jobDescriptor, configurationDescriptor)
}
```
- There are a few other actor definitions that can be added to this file over time. But the only one that Cromwell *requires* to work is the job execution actor.

### Reference conf:

- Reference.conf is a set of reference options which shows people how to enable the backends that they want. So I'll add the initial config which people would add if they wanted the AWS backend (commented out in the reference so it's not enabled by default). This goes below all the other backend references:
```
    #AWS {
    #  actor-factory = "cromwell.backend.impl.aws.AwsBackendActorFactory"
    #  config {
    #
    #  }
    #}
```

### Application.conf

- OK so I've now told people how to add this backend... Now I actually add it to my own personal configuration file so I can try it out!
```
backend {
  default = "AWS"
  providers {
    AWS {
      actor-factory = "cromwell.backend.impl.aws.AwsBackendActorFactory"
      config {
      
      }
    }
  }
}
```

### Trying it out
So we now have a backend skeleton! What happens when we run it? Well hopefully Cromwell will instantiate the backend far enough to reach the unimplemented execute method and then fall over. Let's give it a go!
- I fire up cromwell in server mode with my modified application.conf.
- I create a sample WDL that would sleep for 20 seconds if it actually worked:
The input WDL:
```
task sleep {
  command { sleep 20 }
}
workflow main {
  call sleep
}
```
- I submit the WDL to the swagger endpoint (http://localhost:8000/swagger/index.html?url=/swagger/cromwell.yaml) and watch the server logs...
- And as expected:
```
2016-10-13 13:14:29,017 cromwell-system-akka.dispatchers.engine-dispatcher-39 INFO  - MaterializeWorkflowDescriptorActor [UUID(ddd827ba)]: Call-to-Backend assignments: main.sleep -> AWS
2016-10-13 13:14:30,167 cromwell-system-akka.dispatchers.engine-dispatcher-39 INFO  - WorkflowExecutionActor-ddd827ba-091f-4c6f-b98f-cc9825717007 [UUID(ddd827ba)]: Starting calls: main.sleep:NA:1
2016-10-13 13:14:30,983 cromwell-system-akka.actor.default-dispatcher-5 ERROR - guardian failed, shutting down system
scala.NotImplementedError: an implementation is missing
  at scala.Predef$.$qmark$qmark$qmark(Predef.scala:230)
  at cromwell.backend.impl.aws.AwsJobExecutionActor.execute(AwsJobExecutionActor.scala:12)
```
- OK, so now I just need to implement `execute(): Future[JobExecutionResult]` and Cromwell can interface with AWS. How hard can it be!

## Part 2: Using Amazon to sleep 20 seconds

To be continued...

